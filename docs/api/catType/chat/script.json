{
  "script": {
    "head": "        const version = \"3E8\";\n\n        const gradientStyle = `\n            background-image: linear-gradient(67.5deg, #ff8659, #ffcbb8);\n            -webkit-background-clip: text;\n            background-clip: text;\n            color: transparent;\n            font-size: 24px;\n            font-weight: bold;\n            padding: 10px;\n        `;\n\n        console.log(`%ccatTyper v.${version}`, gradientStyle);\n        console.log(\"What are you doing here?\");\n        console.log(\"To not see IRC messages, run the page with the Query parameter \\\"&NOIRC\\\" or enter in the console: irc_disable = true;\");\n        console.log(\"To not see chat messages in console, run the page with the Query parameter \\\"&NOCONSOLECHAT\\\" or enter in the console: console_chat_disable = true;\");\n        console.log(\"To not see console messages time, run the page with the Query parameter \\\"&NOCONSOLETIME\\\" or enter in the console: console_timestamp_disable = true;\");\n        console.log(\"\");\n",
    "head-SETTINGS": "        const params = new URLSearchParams(window.location.search);\n        const token = params.get('token');\n        const login = params.get('login');\n        const timeFormat = params.get('time_format') || 'HH:mm:ss';\n        const emotesSize = parseFloat(params.get('emotes_size')) || 1.0;\n        const maxHistorySize = parseInt(params.get('history_size')) || 1000;\n        let broadcasterId = params.get('broadcaster_id');\n        const enabledThirdPartyEmotes = params.get('third_party_emotes')?.split(',') || [];\n\n        let irc_disable = params.get('NOIRC') !== null;\n        let console_chat_disable = params.get('NOCONSOLECHAT') !== null;\n        let console_timestamp_disable = params.get('NOCONSOLETIME') !== null;\n",
    "head-TOKENS": "        const clientId = 'xrs6iz7t6zk7z5dfrzad4mn1e4bzln'; // Dont forget to delete that! TomFoolery TeaTime\n",
    "head-HTML": "        const chatEl = document.getElementById('chat');\n        const inputEl = document.getElementById('message-input');\n        inputEl.style.display = 'none';\n",
    "head-OTHER": "        let socket;\n        let reconnectAttempts = 0;\n        let channels = {};\n        let pingers = [\n            { ignoreCase: true, text: login }\n        ];\n        let activeChannel = null;\n        const maxReconnectAttempts = 5;\n        const startTime = new Date();\n        let lastSent = { message: null, channel: null };\n",
    "head-for-global-emotes-and-badges": "        channels[\"global\"] = {\n            chat: null,\n            messages: null,\n            emotes: {},\n            badges: {},\n            tab: null\n        };\n",
    "head-main": "        if (clientId && token) {\n            log('Hello world!', 'INIT');\n            init();\n        }\n",
    "connect": "        function connect() {\n            log('Creating connection to twitch.tv...', 'SOCK');\n            socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');\n\n            socket.onopen = () => {\n                log('Hello, twitch.tv!', 'SOCK');\n                sendSocket(`PASS oauth:${token}`);\n                sendSocket(`NICK ${login}`);\n                sendSocket('CAP REQ :twitch.tv/membership twitch.tv/tags twitch.tv/commands');\n                reconnectAttempts = 0;\n            };\n\n            socket.onmessage = (event) => {\n                const line = event.data.trim();\n                if (!irc_disable) {\n                    log(line, 'SOCK-RECEIVED');\n                }\n\n                if (line.startsWith('PING')) {\n                    log('🏓 Ponged!', 'SOCK');\n                    sendSocket('PONG');\n                    return;\n                }\n\n                const parsed = parseIRCMessage(line);\n\n                switch (parsed.command) {\n                    case 'PRIVMSG':\n                        const username = parsed.tags['display-name'] || parsed.tags.username || 'User';\n                        const message = parsed.params[1];\n                        addMessage(message, parsed.tags, true, parsed.channel);\n                        break;\n\n                    case 'NOTICE':\n                        if (parsed.params[1].includes('Login authentication failed')) {\n                            alert('Authentication failed');\n                        }\n                        break;\n\n                    case 'CLEARCHAT':\n                        if (parsed.params[1]) {\n                            const user = parsed.params[1];\n                            const chatContainer = document.getElementById(`chat-${parsed.channel}`);\n\n                            if (chatContainer) {\n                                const messages = chatContainer.querySelectorAll(`.message`);\n                                messages.forEach(message => {\n                                    const usernameElem = message.querySelector('.username');\n                                    if (usernameElem && usernameElem.textContent.trim().toLowerCase().replace(': ', '') === user.toLowerCase()) {\n                                        message.classList.add('deleted');\n                                    }\n                                });\n                            }\n\n                            if (parsed.tags && parsed.tags['ban-duration']) {\n                                const duration = parseInt(parsed.tags['ban-duration'], 10);\n                                const durationStr = formatDuration(duration);\n                                addSystemMessage(`@${user} was timed out from chat for ${durationStr}`, parsed.channel);\n                            } else {\n                                addSystemMessage(`@${user} has been banned`, parsed.channel);\n                            }\n                        } else {\n                            addSystemMessage('Chat was cleared', parsed.channel);\n                        }\n                        break;\n                    case 'USERSTATE':\n                        if (lastSent.message && lastSent.channel) {\n                            addMessage(lastSent.message, parsed.tags, true, lastSent.channel);\n                            lastSent = { message: null, channel: null };\n                        }\n                        break;\n                    case 'USERNOTICE':\n                        if (parsed.tags['msg-id'] === 'announcement') {\n                            const user = parsed.tags['display-name'] || parsed.tags.username || 'Unknown';\n                            const announcementMessage = parsed.params[1] || '';\n                            const header = '📢 Announcement';\n\n                            addMessage(\n                                announcementMessage,\n                                parsed.tags,\n                                true,\n                                parsed.channel,\n                                'announce',\n                                header\n                            );\n                        }\n                        break;\n                }\n            };\n\n            socket.onclose = (event) => {\n                log('Connection closed. Monka! ' + event.reason, 'SOCK');\n                channels.forEach(function (value, key) {\n                    if (value.chat) {\n                        addSystemMessage('Disconnected', key);\n                    }\n                });\n\n                setTimeout(() => {\n                    reconnectAttempts++;\n                    channels.forEach(function (value, key) {\n                        if (value.chat) {\n                            addSystemMessage(`Reconnecting...`, key);\n                        }\n                    });\n                    log(`Reconnecting...`, 'SOCK');\n                    connect();\n                }, 5000);\n            };\n\n            socket.onerror = (error) => {\n                console.error('WebSocket Error:', error);\n                socket.close();\n            };\n        }\n\n        // Category: UTILS\n        // |========= EMOTES =========|",
    "emotes-replace": "        function replaceEmotes(text, emotes, channel) {\n            text = escapeHTML(text);\n            const originalText = text;\n            text = text.replace(/(https?:\\/\\/[^\\s]+)/g, '<a href=\"$1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">$1</a>');\n\n            // 1. Обработка эмодзи канала\n            let parts = processChannelEmotes(text, channel);\n\n            // 2. Обработка глобальных сторонних эмодзи\n            parts = processGlobalThirdPartyEmotes(parts, channel);\n\n            parts = parts.filter(item => item !== '' && item !== ' ');\n\n            // 3. Обработка Twitch-эмодзи\n            parts = processTwitchEmotes(parts, emotes, originalText);\n\n            return parts.join(' ');\n        }\n",
    "emotes-channel-proccess": "        function processChannelEmotes(text, channel) {\n            const parts = [];\n            if (Object.keys(channels[channel].emotes).length === 0) {\n                return text.split(' ').flatMap(word => [word, ' ']).slice(0, -1);\n            }\n\n            const words = text.split(' ');\n            for (let i = 0; i < words.length; i++) {\n                const word = words[i];\n                if (channels[channel].emotes[word]) {\n                    const img = document.createElement('img');\n                    img.className = 'emote';\n                    img.src = channels[channel].emotes[word].url;\n                    img.style.height = `${1.5 * emotesSize}em`;\n                    img.loading = 'lazy';\n                    img.title = formatEmoteTitle(channels[channel].emotes[word]);\n                    parts.push(img.outerHTML);\n                } else {\n                    parts.push(word);\n                }\n                if (i < words.length - 1) parts.push(' ');\n            }\n\n            return parts;\n        }\n",
    "emotes-global-tp-proccess": "        function processGlobalThirdPartyEmotes(parts, channel) {\n            if (Object.keys(channels[\"global\"].emotes).length === 0) return parts;\n\n            const result = [];\n            for (const part of parts) {\n                if (part.startsWith('<img')) {\n                    result.push(part);\n                    continue;\n                }\n\n                const words = part.split(' ');\n                for (let i = 0; i < words.length; i++) {\n                    const word = words[i];\n                    if (channels[\"global\"].emotes[word]) {\n                        const img = document.createElement('img');\n                        img.className = 'emote';\n                        img.src = channels[\"global\"].emotes[word].url;\n                        img.style.height = `${1.5 * emotesSize}em`;\n                        img.loading = 'lazy';\n                        img.title = formatEmoteTitle(channels[\"global\"].emotes[word]);\n                        result.push(img.outerHTML);\n                    } else {\n                        result.push(word);\n                    }\n                    if (i < words.length - 1) result.push(' ');\n                }\n            }\n\n            return result;\n        }\n",
    "emotes-twitch-proccess": "        function processTwitchEmotes(parts, emotes, originalText) {\n            if (!emotes || !originalText) return parts;\n\n            const result = [...parts];\n            const wordPositions = [];\n\n            let pos = 0;\n            originalText.split(\" \").forEach((word, index) => {\n                const start = pos;\n                const end = pos + word.length;\n                wordPositions.push({ start, end, index });\n                pos = end + 1;\n            });\n\n            const emoteList = [];\n            emotes.split(\"/\").forEach(part => {\n                const [id, positions] = part.split(\":\");\n                positions.split(\",\").forEach(pos => {\n                    const [start, end] = pos.split(\"-\").map(Number);\n                    emoteList.push({ id, start, end });\n                });\n            });\n\n            emoteList.sort((a, b) => a.start - b.start);\n\n            emoteList.forEach(({ id, start, end }) => {\n                for (let i = 0; i < wordPositions.length; i++) {\n                    const { start: wordStart, end: wordEnd, index: wordIndex } = wordPositions[i];\n\n                    if (start >= wordStart && end <= wordEnd) {\n                        const img = document.createElement(\"img\");\n                        img.className = \"emote\";\n                        img.loading = 'lazy';\n                        img.src = `https://static-cdn.jtvnw.net/emoticons/v2/${id}/default/dark/3.0`;\n                        img.style.height = `${1.5 * emotesSize}em`;\n\n                        result[wordIndex] = img.outerHTML;\n                        break;\n                    }\n                }\n            });\n\n            return result;\n        }\n",
    "emotes-format": "        function formatEmoteTitle(emoteData) {\n            return `${emoteData.name}\n${emoteData.type} ${emoteData.service} emote\nBy ${emoteData.author}${emoteData.original_name !== emoteData.name ? `\\nOriginal name: ${emoteData.original_name}` : ''}`;\n        }\n",
    "escape-html": "        function escapeHTML(text) {\n            return text\n                .replaceAll(/[&<>\"']/g, (match) => ({\n                    '&': '&amp;',\n                    '<': '&lt;',\n                    '>': '&gt;',\n                    '\"': '&quot;',\n                    \"'\": '&#39;'\n                }[match]));\n        }\n        // |==========================|\n\n\n        // |===== USERNAME COLOR =====|",
    "color-map": "        const colorMapping = {\n            \"#0000FF\": \"#5678fc\",    // Blue\n            \"#8A2BE2\": \"#b24dff\",    // BlueViolet\n            \"#5F9EA0\": \"#5ea0c4\",    // CadetBlue\n            \"#D2691E\": \"#fc8530\",    // Chocolate\n            \"#FF7F50\": \"#fa895f\",    // Coral\n            \"#1E90FF\": \"#3b9eff\",    // DodgerBlue\n            \"#B22222\": \"#ff4a4a\",    // FireBrick\n            \"#DAA520\": \"#ffce54\",    // GoldenRod\n            \"#00FF00\": \"#82ff82\",    // Green\n            \"#FF69B4\": \"#FF69B4\",    // HotPink\n            \"#FF4500\": \"#ff6e38\",    // OrangeRed\n            \"#FF0000\": \"#ff4242\",    // Red\n            \"#2E8B57\": \"#499e6e\",    // SeaGreen\n            \"#00FF7F\": \"#3dff9e\",    // SpringGreen\n            \"#9ACD32\": \"#c3f759\",    // YellowGreen\n        };\n",
    "get-custom-color": "        function getCustomColor(hex) {\n            return colorMapping[hex] || hex; // Используем кастомный цвет или оригинальный\n        }\n        // |==========================|\n\n\n        // |========= SOCKET =========|",
    "socket-send": "        function sendSocket(data) {\n            if (socket && socket.readyState === WebSocket.OPEN) {\n                socket.send(data);\n\n                if (!irc_disable) {\n                    log(data, 'SOCK SEND');\n                }\n            }\n            else {\n                log(`Tried to send message, but socket is not open!`, 'SOCK SEND');\n            }\n        }\n",
    "tw-send-message": "        function sendMessage(message, channel) {\n            if (socket && socket.readyState === WebSocket.OPEN) {\n                lastSent = { message: message, channel: channel };\n                sendSocket(`PRIVMSG #${channel} :${message}`);\n                log(`Sended message to #${channel}: ${message}`, 'SM');\n            }\n            else {\n                log(`Tried to send message, but socket is not open!`, 'SM');\n            }\n        }\n        // |==========================|\n\n\n        // |========= BADGES =========|",
    "badges-proccess": "        function processBadgeData(data, channel) {\n            data.data.forEach(badge => {\n                badge.versions.forEach(version => {\n                    const key = `${badge.set_id}/${version.id}`;\n                    channels[channel].badges[key] = version.image_url_4x;\n                });\n            });\n        }\n\t\t",
    "badges-load": "        async function loadBadges(clientId, token, broadcasterId, channel) {\n            try {\n                log(`Loading badges for #${channel} (${broadcasterId})...`, 'LB');\n                if (broadcasterId) {\n                    const channelRes = await fetch(`https://api.twitch.tv/helix/chat/badges?broadcaster_id=${broadcasterId}`, {\n                        headers: {\n                            'Client-ID': clientId,\n                            'Authorization': `Bearer ${token}`\n                        }\n                    });\n                    const channelData = await channelRes.json();\n                    processBadgeData(channelData, channel);\n                    log(`Loaded! Quantity: ${Object.keys(channels[channel].badges).length}`, 'LB');\n                }\n            } catch (error) {\n                log(`Error loading local badges: ${error.message}`, 'LB');\n                console.error(error);\n            }\n        }\n",
    "badges-load-global": "        async function loadGlobalBadges(clientId, token) {\n            try {\n                log(`Loading global badges...`, 'LGB');\n                const globalRes = await fetch('https://api.twitch.tv/helix/chat/badges/global', {\n                    headers: {\n                        'Client-ID': clientId,\n                        'Authorization': `Bearer ${token}`\n                    }\n                });\n                const globalData = await globalRes.json();\n                processBadgeData(globalData, \"global\");\n                log(`Loaded! Quantity: ${Object.keys(channels['global'].badges).length}`, 'LGB');\n            } catch (error) {\n                log(`Error loading global badges: ${error.message}`, 'LB');\n                console.error(error);\n            }\n        }\n",
    "badges-parse": "        function parseBadges(badgesStr) {\n            if (!badgesStr) return [];\n            return badgesStr.split(',').map(badge => {\n                const [setId, version] = badge.split('/');\n                return { setId, version };\n            });\n        }\n        // |==========================|\n\n\n        // |========== CHAT ==========|",
    "chat-add-system-message": "        function addSystemMessage(text, channel) {\n            const msgDiv = document.createElement('div');\n            msgDiv.className = 'message';\n\n            const timeSpan = document.createElement('span');\n            timeSpan.className = 'timestamp';\n            timeSpan.textContent = formatTime(Date.now());\n            msgDiv.appendChild(timeSpan);\n\n            const systemSpan = document.createElement('span');\n            systemSpan.style.color = '#888';\n            systemSpan.textContent = text;\n            msgDiv.appendChild(systemSpan);\n\n            if (!console_chat_disable) {\n                log(`@S #${channel} system: ${text}`, 'CHAT');\n            }\n\n            const chatEl = channels[channel].chat;\n            if (!chatEl) {\n                chatEl = document.getElementById(`chat-${channel}`);\n            }\n\n            const atBottom = chatEl.scrollTop + chatEl.clientHeight >= chatEl.scrollHeight - 5;\n\n            chatEl.appendChild(msgDiv);\n\n            if (atBottom) {\n                chatEl.scrollTop = chatEl.scrollHeight;\n            }\n\n            if (chatEl.children.length > maxHistorySize) {\n                chatEl.removeChild(chatEl.firstElementChild);\n            }\n        }\n",
    "chat-read-send": "        inputEl.addEventListener('keypress', (e) => {\n            if (e.key === 'Enter' && inputEl.value.trim()) {\n                sendMessage(inputEl.value, activeChannel);\n                inputEl.value = '';\n            }\n        }); // Read send\n\t\t",
    "chat-add-message": "        function addMessage(message, tags, isAppend, channel, extraClasses = '', headerText = '') {\n            const msgDiv = document.createElement('div');\n            msgDiv.className = `message ${extraClasses}`.trim();\n            const originalMessage = message;\n\n            if (headerText) {\n                const headerSpan = document.createElement('div');\n                headerSpan.className = 'message-header';\n                headerSpan.textContent = headerText;\n                msgDiv.appendChild(headerSpan);\n            }\n\n            let msgInfo = '';\n\n            // Store message ID for replies\n            if (tags['id']) {\n                msgDiv.id = `msg-${tags['id']}`;\n            }\n\n            let isAction = false;\n            if (message.startsWith('\\x01ACTION') && message.endsWith('\\x01')) {\n                isAction = true;\n                message = message.slice(8, -1);\n                msgInfo += 'M';\n            }\n\n            // Reply handling\n            const parentId = tags['reply-parent-msg-id'];\n            if (parentId) {\n                msgInfo += 'R';\n                const parentMsg = document.getElementById(`msg-${parentId}`);\n                if (parentMsg) {\n                    const replyRef = document.createElement('div');\n                    replyRef.className = 'reply-reference';\n\n                    let msg = parentMsg.querySelector('.message-content').textContent;\n\n                    replyRef.innerHTML = `→ In reply to ${parentMsg.querySelector('.username').textContent}${msg.slice(0, 75) + (msg === msg.slice(0, 72) ? \"\" : \"...\")}`;\n                    replyRef.style.cssText = \"margin-left: 10px; padding-left: 10px; border-left: 1px solid #555; cursor: pointer; font-style: italic;\";\n\n                    replyRef.addEventListener('click', () => {\n                        parentMsg.scrollIntoView({ behavior: 'smooth', block: 'center' });\n\n                        parentMsg.classList.add('highlight');\n                        setTimeout(() => {\n                            parentMsg.classList.remove('highlight');\n                        }, 1000);\n                    });\n\n                    msgDiv.appendChild(replyRef);\n                    message = message.slice(parentMsg.querySelector('.username').textContent.replaceAll(': ', '').length + 2);\n                }\n            }\n\n            // time\n            const timeSpan = document.createElement('span');\n            timeSpan.className = 'timestamp';\n            timeSpan.textContent = formatTime(tags['tmi-sent-ts'] ? parseInt(tags['tmi-sent-ts']) : Date.now());\n            msgDiv.appendChild(timeSpan);\n\n            // badges\n            const badgesContainer = document.createElement('span');\n            badgesContainer.className = 'badges';\n            if (tags.badges) {\n                const badges = parseBadges(tags.badges);\n                badges.forEach(badge => {\n                    const badgeUrl = channels[channel].badges[`${badge.setId}/${badge.version}`];\n                    const badgeGlobalUrl = channels['global'].badges[`${badge.setId}/${badge.version}`];\n                    if (badgeUrl || badgeGlobalUrl) {\n                        const img = document.createElement('img');\n                        if (badgeUrl) {\n                            img.src = badgeUrl;\n                        } else {\n                            img.src = badgeGlobalUrl;\n                        }\n                        img.className = 'badge';\n                        img.title = badge.setId;\n                        badgesContainer.appendChild(img);\n                    }\n                });\n            }\n            msgDiv.appendChild(badgesContainer);\n\n            // username\n            const userSpan = document.createElement('span');\n            userSpan.className = 'username';\n            const originalColor = tags['color'] || '#b3b3b3';\n            const customColor = getCustomColor(originalColor);\n            userSpan.style.color = customColor;\n            userSpan.textContent = (tags['display-name'] || tags.username || 'undefined') + (isAction ? ' ' : ': ');\n            msgDiv.appendChild(userSpan);\n\n            // message\n            const messageSpan = document.createElement('span');\n            messageSpan.className = 'message-content';\n            messageSpan.innerHTML = replaceEmotes(message, tags['emotes'], channel);\n            if (isAction) {\n                messageSpan.style.color = customColor;\n            }\n            msgDiv.appendChild(messageSpan);\n\n            for (const { ignoreCase, text } of pingers) {\n                const message = ignoreCase ? originalMessage.toLowerCase() : originalMessage;\n                const target = ignoreCase ? text.toLowerCase() : text;\n\n                if (message.includes(target)) {\n                    msgDiv.classList.add('ping');\n                    break;\n                }\n            }\n\n            const tabEl = channels[channel].tab;\n\n            if (!tabEl) {\n                tabEl = document.getElementById(`tab-${channel}`);\n            }\n\n            if (!tabEl.classList.contains('active')) {\n                for (const { ignoreCase, text } of pingers) {\n                    const message = ignoreCase ? originalMessage.toLowerCase() : originalMessage;\n                    const target = ignoreCase ? text.toLowerCase() : text;\n\n                    if (message.includes(target)) {\n                        tabEl.classList.add('ping');\n                        break;\n                    }\n                }\n\n                if (!tabEl.classList.contains('ping')) {\n                    tabEl.classList.add('messages');\n                }\n            }\n\n            const chatEl = channels[channel].chat;\n\n            if (!chatEl) {\n                chatEl = document.getElementById(`chat-${channel}`);\n            }\n\n            const atBottom = chatEl.scrollTop + chatEl.clientHeight >= chatEl.scrollHeight - 5;\n\n            if (isAppend) {\n                chatEl.appendChild(msgDiv);\n            } else {\n                chatEl.prepend(msgDiv);\n            }\n\n            if (atBottom) {\n                chatEl.scrollTop = chatEl.scrollHeight;\n            }\n\n            // Message limit\n            if (chatEl.children.length > maxHistorySize) {\n                chatEl.removeChild(chatEl.firstElementChild);\n            }\n\n            if (!console_chat_disable) {\n                log(`@${msgInfo} #${channel} ${tags['display-name'] || tags.username || 'undefined'}: ${message}`, 'CHAT');\n            }\n        }\n",
    "chat-timestamp-format": "        function formatTime(timestamp) {\n            const date = new Date(timestamp);\n            const hours = String(date.getHours()).padStart(2, '0');\n            const minutes = String(date.getMinutes()).padStart(2, '0');\n            const seconds = String(date.getSeconds()).padStart(2, '0');\n            const miliseconds = String(date.getMilliseconds()).padStart(2, '0');\n\n            return timeFormat\n                .replace('HH', hours)\n                .replace('mm', minutes)\n                .replace('ss', seconds)\n                .replace('SSS', miliseconds);\n        }\n\t\t",
    "chat-parse-IRC": "        function parseIRCMessage(line) {\n            const tags = {};\n            let prefix = '';\n            let command = '';\n            let params = [];\n            let channel = undefined;\n\n            // tags\n            if (line.startsWith('@')) {\n                const tagEnd = line.indexOf(' ');\n                const tagString = line.slice(1, tagEnd);\n                line = line.slice(tagEnd + 1);\n\n                tagString.split(';').forEach(tag => {\n                    const [key, value] = tag.split('=');\n                    tags[key] = value || '';\n                });\n            }\n\n            // prefix\n            if (line.startsWith(':')) {\n                const prefixEnd = line.indexOf(' ');\n                prefix = line.slice(1, prefixEnd);\n                line = line.slice(prefixEnd + 1);\n            }\n\n            // command\n            const commandEnd = line.indexOf(' ');\n            command = line.slice(0, commandEnd);\n            line = line.slice(commandEnd + 1);\n\n            // parameters\n            while (line.length > 0) {\n                if (line.startsWith(':')) {\n                    params.push(line.slice(1));\n                    line = '';\n                } else {\n                    const spaceIndex = line.indexOf(' ');\n                    if (spaceIndex === -1) {\n                        params.push(line);\n                        line = '';\n                    } else {\n                        params.push(line.slice(0, spaceIndex));\n                        line = line.slice(spaceIndex + 1);\n                    }\n                }\n            }\n            \n            if ((command === 'PRIVMSG' || command === 'CLEARCHAT' || command === 'USERNOTICE') && params.length > 0) {\n                channel = params[0].replace('#', '');\n            }\n\n            return {\n                tags,\n                prefix,\n                command,\n                params,\n                channel\n            };\n        }\n",
    "chat-load-history": "        async function loadHistoricalMessages(channel) {\n            if (!channel) return;\n\n            try {\n                log(`Getting for #${channel}...`, 'HISTORY');\n                const res = await fetch(`https://recent-messages.robotty.de/api/v2/recent-messages/${channel}`, {\n                    headers: { 'Accept': 'application/json' }\n                });\n\n                if (!res.ok) throw new Error('HTTP error ' + res.status);\n\n                const data = await res.json();\n                if (data.error) throw new Error(data.error);\n\n                // Process messages in reverse to maintain order\n                for (const line of data.messages) {\n                    const parsed = parseIRCMessage(line.trim());\n                    if (parsed.command === 'PRIVMSG') {\n                        addMessage(parsed.params[1], parsed.tags, true, channel);\n                    } else if (parsed.command === 'CLEARCHAT') {\n                        if (parsed.params[1]) {\n                            const user = parsed.params[1];\n                            const chatContainer = document.getElementById(`chat-${parsed.channel}`);\n\n                            if (chatContainer) {\n                                const messages = chatContainer.querySelectorAll(`.message`);\n                                messages.forEach(message => {\n                                    const usernameElem = message.querySelector('.username');\n                                    if (usernameElem && usernameElem.textContent.trim().toLowerCase().replaceAll(':', '').replaceAll(' ', '') === user.toLowerCase()) {\n                                        message.classList.add('deleted');\n                                    }\n                                });\n                            }\n\n                            if (parsed.tags && parsed.tags['ban-duration']) {\n                                const duration = parseInt(parsed.tags['ban-duration'], 10);\n                                const durationStr = formatDuration(duration);\n                                addSystemMessage(`@${user} was timed out from chat for ${durationStr}`, parsed.channel);\n                            } else {\n                                addSystemMessage(`@${user} has been banned`, parsed.channel);\n                            }\n                        } else {\n                            addSystemMessage('Chat was cleared', parsed.channel);\n                        }\n                    } else if (parsed.command === 'USERNOTICE') {\n                        if (parsed.tags['msg-id'] === 'announcement') {\n                            const user = parsed.tags['display-name'] || parsed.tags.username || 'Unknown';\n                            const announcementMessage = parsed.params[1] || '';\n                            const header = '📢 Announcement';\n\n                            addMessage(\n                                announcementMessage,\n                                parsed.tags,\n                                true,\n                                parsed.channel,\n                                'announce',\n                                header\n                            );\n                        }\n                    }\n                }\n                log(`Loaded for #${channel}!`, 'HISTORY');\n            } catch (error) {\n                addSystemMessage('History load failed: ' + error.message, channel);\n                log(`Error loading for #${channel}!`, 'HISTORY');\n                console.error(error);\n            }\n        }\n\t\t",
    "chat-duration-format": "        function formatDuration(seconds) {\n            if (seconds < 60) {\n                return `${seconds} second${seconds === 1 ? '' : 's'}`;\n            } else if (seconds < 3600) {\n                const minutes = Math.floor(seconds / 60);\n                return `${minutes} minute${minutes === 1 ? '' : 's'}`;\n            } else if (seconds < 86400) {\n                const hours = Math.floor(seconds / 3600);\n                return `${hours} hour${hours === 1 ? '' : 's'}`;\n            } else {\n                const days = Math.floor(seconds / 86400);\n                return `${days} day${days === 1 ? '' : 's'}`;\n            }\n        }\n        // |==========================|\n\n\n        // |======= TWITCH API =======|",
    "API-get-ID": "        async function getBroadcasterId(channelName, clientId, token) {\n            log(`Getting #${channelName} id...`, 'GBI');\n            const res = await fetch(`https://api.twitch.tv/helix/users?login=${channelName}`, {\n                headers: {\n                    'Client-ID': clientId,\n                    'Authorization': `Bearer ${token}`\n                }\n            });\n            const data = await res.json();\n            log(`#${channelName} → ${data.data[0]?.id}`, 'GBI');\n            return data.data[0]?.id;\n        }\n        // |==========================|\n\n\n        // |=== THIRD PARTY EMOTES ===|",
    "tp-emotes-load-global": "        async function loadGlobalThirdPartyEmotes() {\n            log(`Loading global third party emotes... (${enabledThirdPartyEmotes.join(', ')})`, 'LGTPE');\n            const promises = [];\n\n            if (enabledThirdPartyEmotes.includes('7TV')) {\n                promises.push(loadGlobal7TVEmotes());\n            }\n            if (enabledThirdPartyEmotes.includes('BTTV')) {\n                promises.push(loadGlobalBTTVEmotes());\n            }\n            if (enabledThirdPartyEmotes.includes('FFZ')) {\n                promises.push(loadGlobalFFZEmotes());\n            }\n\n            await Promise.allSettled(promises);\n            log(`Loaded!`, 'LGTPE');\n        }\n\t\t",
    "tp-emotes-load-global-7tv": "        async function loadGlobal7TVEmotes() {\n            try {\n                const globalRes = await fetch('https://7tv.io/v3/emote-sets/global');\n                const globalData = await globalRes.json();\n                process7TVEmotes(globalData.emotes, 'Global', 0, 'global');\n            } catch (error) {\n                console.error('7TV global emotes load error:', error);\n                //addSystemMessage(\"7TV global emotes load error\");\n            }\n        }\n",
    "tp-emotes-load-global-BTTV": "        async function loadGlobalBTTVEmotes() {\n            try {\n                const globalRes = await fetch('https://api.betterttv.net/3/cached/emotes/global');\n                const globalData = await globalRes.json();\n                processBTTVEmotes(globalData, 'Global', 0, 'global');\n            } catch (error) {\n                console.error('BTTV global emotes load error:', error);\n                //addSystemMessage(\"BTTV global emotes load error\");\n            }\n        }\n",
    "tp-emotes-load-global-FFZ": "        async function loadGlobalFFZEmotes() {\n            try {\n                const globalRes = await fetch('https://api.frankerfacez.com/v1/set/3');\n                const globalData = await globalRes.json();\n                processFFZEmotes(globalData.set.emoticons, 'Global', 0, 'global');\n            } catch (error) {\n                console.error('FFZ global emotes load error:', error);\n                //addSystemMessage(\"FFZ global emotes load error\");\n            }\n        }\n",
    "tp-emotes-load-local": "        // LOCAL EMOTES\n        async function loadThirdPartyEmotes(id, channel) {\n            log(`Loading third party emotes for #${channel} (${id})... (${enabledThirdPartyEmotes.join(', ')})`, 'LTPE');\n            const promises = [];\n\n            if (enabledThirdPartyEmotes.includes('7TV')) {\n                promises.push(load7TVEmotes(id, channel));\n            }\n            if (enabledThirdPartyEmotes.includes('BTTV')) {\n                promises.push(loadBTTVEmotes(id, channel));\n            }\n            if (enabledThirdPartyEmotes.includes('FFZ')) {\n                promises.push(loadFFZEmotes(id, channel));\n            }\n\n            await Promise.allSettled(promises);\n            log(`Loaded!`, 'LTPE');\n        }\n",
    "tp-emotes-load-local-7tv": "        async function load7TVEmotes(id, channel) {\n            try {\n                const channelRes = await fetch(`https://7tv.io/v3/users/twitch/${id}`);\n                const channelData = await channelRes.json();\n                process7TVEmotes(channelData.emote_set.emotes, 'Channel', 1, channel);\n            } catch (error) {\n                log(`7TV error: ` + error.message, 'load7TVEmotes');\n                console.error(error);\n                addSystemMessage(\"7TV channel emotes load error\", channel);\n            }\n        }\n",
    "tp-emotes-load-local-BTTV": "        async function loadBTTVEmotes(id, channel) {\n            try {\n                const channelRes = await fetch(`https://api.betterttv.net/3/cached/users/twitch/${id}`);\n                const channelData = await channelRes.json();\n                processBTTVEmotes(channelData.sharedEmotes, 'Shared channel', 1, channel);\n                processBTTVEmotes(channelData.channelEmotes, 'Channel', 2, channel);\n            } catch (error) {\n                log(`BTTV error: ` + error.message, 'loadBTTVEmotes');\n                console.error(error);\n                addSystemMessage(\"BTTV load error\", channel);\n            }\n        }\n",
    "tp-emotes-load-local-FFZ": "        async function loadFFZEmotes(id, channel) {\n            try {\n                const channelRes = await fetch(`https://api.frankerfacez.com/v1/room/id/${id}`);\n                const channelData = await channelRes.json();\n                const setId = channelData.room.set;\n                const setRes = await fetch(`https://api.frankerfacez.com/v1/set/${setId}`);\n                const setData = await setRes.json();\n                processFFZEmotes(setData.set.emoticons, 'Channel', 1, channel);\n            } catch (error) {\n                log(`FFZ error: ` + error.message, 'loadFFZEmotes');\n                console.error(error);\n                addSystemMessage(\"FFZ load error\", channel);\n            }\n        }\n",
    "tp-emotes-proccess-BTTV": "        // PROCCESS EMOTES\n        function processBTTVEmotes(emotes, prefix, type_id, channel) {\n            emotes.forEach(e => {\n                try {\n                    channels[channel].emotes[e.code] = {\n                        url: `https://cdn.betterttv.net/emote/${e.id}/3x`,\n                        service: 'bttv',\n                        type: prefix,\n                        type_id: type_id,\n                        is_zero_lenght: false,\n                        author: (prefix != 'Global' ? (prefix != 'Channel' ? (e.hasOwnProperty('user') && e.user.hasOwnProperty('name') ? e.user.name : '<suspended user>') : channel) : 'BTTV'),\n                        author_url: (e.hasOwnProperty('user') && e.user.hasOwnProperty('id')) || e.hasOwnProperty('userId') ? `https://betterttv.com/users/${(prefix != 'Global' & prefix != 'Channel' ? e.user.id : e.userId)}` : '',\n                        emote_url: `https://betterttv.com/emotes/${e.id}`,\n                        id: e.id,\n                        original_name: e.code,\n                        name: e.code\n                    };\n                } catch (error) {\n                    log(`BTTV emote process error`, 'PBTTVE');\n                    console.error(error);\n                }\n            });\n        }\n",
    "tp-emotes-proccess-FFZ": "        function processFFZEmotes(emotes, prefix, type_id, channel) {\n            emotes.forEach(e => {\n                try {\n                    const size = Math.min(4, Math.floor(emotesSize * 2)); // 1x, 2x или 4x\n                    channels[channel].emotes[e.name] = {\n                        url: e.urls[size] || e.urls['2'],\n                        service: 'ffz',\n                        type: prefix,\n                        type_id: type_id,\n                        is_zero_lenght: false,\n                        author: e.hasOwnProperty('owner') && e.owner.hasOwnProperty('display_name') ? e.owner.display_name : '<suspended user>',\n                        author_url: e.hasOwnProperty('owner') && e.owner.hasOwnProperty('display_name') ? `https://www.frankerfacez.com/${e.owner.display_name}/submissions` : '',\n                        emote_url: `https://www.frankerfacez.com/emoticon/${e.id}-${e.name}`,\n                        id: e.id,\n                        original_name: e.name,\n                        name: e.name\n                    };\n                } catch (error) {\n                    log(`FFZ emote process error`, 'PFFZE');\n                    console.error(error);\n                }\n            });\n        }\n",
    "tp-emotes-proccess-7tv": "        function process7TVEmotes(emotes, prefix, type_id, channel) {\n            emotes.forEach(e => {\n                try {\n                    const bestQuality = e.data.host.files.reduce((best, current) =>\n                        current.width > best.width ? current : best\n                    );\n                    channels[channel].emotes[e.name] = {\n                        url: `https:${e.data.host.url}/${bestQuality.name}`,\n                        service: '7tv',\n                        type: prefix,\n                        type_id: type_id,\n                        is_zero_lenght: e.data.flags == 256,\n                        author: e.data.hasOwnProperty('owner') && e.data.owner.hasOwnProperty('display_name') ? e.data.owner.display_name : '<suspended user>',\n                        author_url: e.data.hasOwnProperty('owner') && e.data.owner.hasOwnProperty('id') ? `https://7tv.app/users/${e.data.owner.id}` : '',\n                        emote_url: `https://7tv.app/emotes/${e.id}`,\n                        id: e.id,\n                        original_name: e.data.name,\n                        name: e.name\n                    };\n                } catch (error) {\n                    log(`7TV emote process error`, 'P7TVE');\n                    console.error(error);\n                }\n            });\n        }\n        // |==========================|\n",
    "tab-init": "        // |========== TABS ==========|\n        function initTab(channelName) {\n            log(`Inititalization for #${channelName}...`, 'TABINIT');\n            const tabsContainer = document.getElementById('tabs-container');\n            const tab = document.createElement('div');\n            tab.className = 'tab';\n            tab.id = `tab-${channelName}`;\n            tab.textContent = channelName;\n            tab.addEventListener('click', () => switchChannel(channelName));\n            tabsContainer.appendChild(tab);\n\n            const chat = document.createElement('div');\n            chat.id = `chat-${channelName}`;\n            chat.className = 'chat-container';\n            chat.style.display = 'none';\n            document.body.insertBefore(chat, document.getElementById('input-container'));\n\n            channels[channelName] = {\n                chat: chat,\n                messages: [],\n                emotes: {},\n                badges: {},\n                tab: tab\n            };\n            log(`Inititalized!`, 'TABINIT');\n        }\n\t\t",
    "tab-switch": "        function switchChannel(channelName) {\n            let oldChannel = activeChannel;\n            \n            if (activeChannel) {\n                channels[activeChannel].chat.style.display = 'none';\n            }\n            activeChannel = channelName;\n            channels[activeChannel].chat.style.display = 'block';\n            channels[activeChannel].chat.scrollTop = channels[activeChannel].chat.scrollHeight;\n            inputEl.style.display = 'block';\n\n            if (oldChannel) {\n                let oldChannelTabEl = document.getElementById(`tab-${oldChannel}`);\n                oldChannelTabEl.classList.remove('active');\n            }\n            let newChannelTabEl = document.getElementById(`tab-${channelName}`);\n            newChannelTabEl.className = 'tab active';\n\n            log(`#${oldChannel} → #${activeChannel}`, 'SC');\n        }\n",
    "tab-add-button-read": "        document.getElementById('add-tab-btn').addEventListener('click', () => {\n            let newChannel = prompt('Enter channel name:');\n            if (newChannel) {\n                newChannel = newChannel.toLowerCase();\n\n                if (!channels[newChannel]) {\n                    log(`Adding new channel - #${newChannel}`, 'ATBC');\n                    initTab(newChannel);\n                    switchChannel(newChannel);\n                    loadChannelData(newChannel);\n                    log(`#${newChannel} added!`, 'ATBC');\n                }\n            }\n        });\n\t\t",
    "tab-load-channel-data": "        async function loadChannelData(channelName) {\n            log(`Loading channel data for #${channelName}...`, 'LCD');\n            const channelData = channels[channelName];\n\n            const id = await getBroadcasterId(channelName, clientId, token);\n            if (id) {\n                channelData.broadcasterId = id;\n\n                await Promise.allSettled([\n                    loadBadges(clientId, token, id, channelName),\n                    loadThirdPartyEmotes(channelData.broadcasterId, channelName)\n                ]);\n\n                addSystemMessage('Third-party emotes loaded', channelName);\n                await loadHistoricalMessages(channelName);\n\n                sendSocket(`JOIN #${channelName}`);\n                log(`Data for #${channelName} was loaded!`, 'LCD');\n            }\n            else {\n                addSystemMessage('This channel was not found!', channelName);\n                log(`#${channelName} was not found!`, 'LCD');\n            }\n        }\n        // |==========================|\n",
    "init": "        // START\n        async function init() {\n            log(`Waking up...`, 'INIT');\n            // Existing badge loading logic...\n            await Promise.allSettled([\n                loadGlobalBadges(clientId, token),\n                loadGlobalThirdPartyEmotes()\n            ]);\n\n            log(`Good morning!`, 'INIT');\n            log(`Emotes loaded: ${Object.keys(channels[\"global\"].emotes).length}`, 'INIT');\n            connect();\n        }\n",
    "log": "        // LOG\n        function log(text, section) {\n            const sectionStyle = `\n                background-image: linear-gradient(67.5deg, #ff8659, #ffcbb8);\n                color: transparent;\n                background-clip: text;\n            `;\n            if (console_timestamp_disable) {\n                console.log(`[%c${section}%c] ${text}`, sectionStyle, '');\n            } else {\n                console.log(`[%c${new Date() - startTime}%c] [%c${section}%c] ${text}`, sectionStyle, '', sectionStyle, '');\n            }\n        }"
  },
  "script-version": "3E8",
  "last-update": "06/23/2025 04:23:06",
  "script-name": "catTyper-main",
  "author": "itzkitb",
  "url": "itzkitb.lol"
}
