<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Twitch Chat</title>
    <style>
        body {
            font-family: "Manrope", sans-serif;
            background: #18181b;
            color: #fff;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #status {
            background: #9147ff;
            padding: 10px;
            text-align: center;
            font-weight: bold;
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding: 6px;
            will-change: scroll-position;
            padding-top: 65px;
        }

        .chat-container::-webkit-scrollbar {
            width: 10px;
            height: 8px;
            background-color: #00000000;
        }

        .chat-container::-webkit-scrollbar-thumb {
            background-color: #52525250;
            border-radius: 20px 0px 0px 20px;
        }

        .message {
            margin: 2px 0px;
            padding: 3px 5px;
            transition: background-color 0.5s ease, border 0.5s ease;
            overflow: hidden;
            border: solid 1px #ffffff00;
            border-radius: 10px;
        }

        .message.ping {
            background: #ff363635;
            border: solid 1px #ff363620;
        }

        .chat-container img {
            vertical-align: middle;
        }

        .timestamp {
            font-family: "Ubuntu Mono", monospace;
            font-weight: 400;
            color: #919191;
            margin-right: 5px;
            min-width: 50px;
        }

        .username {
            font-family: "Manrope", sans-serif;
            font-optical-sizing: auto;
            font-weight: 700;
            font-style: normal;
            padding-bottom: 5px;
        }

        .emote {
            height: 1.5em;
            margin: 0 2px;
            border-radius: 3px;
            max-width: 100%;
        }

        #input-container {
            display: flex;
            margin: 0px 8px 8px 8px;
        }

        #message-input {
            flex: 1;
            padding: 10px;
            border: none;
            background: #27272a60;
            color: #fff;
            font-size: 16px;
            border-radius: 10px;
            background: #ffffff05;
        }

        #message-input:focus {
            outline: none;
        }

        .badge {
            height: 1.2em;
            vertical-align: middle;
            margin-right: 4px;
            border-radius: 3px;
        }

        .badges {
            display: inline-flex;
            align-items: center;
            vertical-align: middle;
        }

        .reply-reference {
            margin: 5px 0 0 0;
            padding-left: 10px;
            border-left: 1px solid #444;
            cursor: pointer;
            font-style: italic;
            color: #aaa;
            transition: color 0.5s ease;
        }

        .reply-reference:hover {
            color: #fff;
        }

        .message.highlight {
            background-color: #ffffff25;
            border: solid 1px #ffffff30;
        }

        .message.announce {
            background-color: #9147ff25;
            border: solid 1px #9147ff30;
        }

        .message.deleted {
            opacity: 0.5;
        }

        .message.deleted .message-content {
            text-decoration: line-through;
        }

        #tab-bar {
            display: flex;
            position: fixed;
            align-items: center;
            background: #ffffff05;
            padding: 10px;
            padding-bottom: 5px;
            margin: 8px 0px 0px 8px;
            border-radius: 20px;
            width: calc(100% - 36px);
            backdrop-filter: blur(5px);
            border: solid 1px #ffffff05;
        }

        #tabs-container {
            display: flex;
            flex-grow: 1;
            overflow-x: auto;
            border-radius: 10px 10px 0px 0px;
            margin-right: 8px;
            padding-bottom: 5px;
        }

        #tabs-container::-webkit-scrollbar {
            width: 10px;
            height: 8px;
            background-color: #00000000;
        }

        #tabs-container::-webkit-scrollbar-thumb {
            background-color: #ffffff05;
            border-radius: 20px;
            border: solid 1px #ffffff05;
        }

        .tab {
            padding: 5px 10px;
            margin-right: 5px;
            background: #ffffff0D;
            border-radius: 10px;
            cursor: pointer;
            white-space: nowrap;
            border: solid 1px #ffffff05;
            transition: 0.35s ease background, 0.35s ease border;
            user-select: none;
        }

        .tab.active {
            background: #ffffff30;
            border: solid 1px #ffffff15;
        }

        .tab.messages {
            background: #ffffff0D;
            border: solid 1px #ffffff30;
        }

        .tab.ping {
            background: #ff363630;
            border: solid 1px #ff363615;
        }

        #add-tab-btn {
            font-family: "Ubuntu Mono", monospace;
            font-weight: 400;
            align-content: center;
            background: #ffffff15;
            color: white;
            font-size: 18px;
            padding: 0 10px;
            cursor: pointer;
            border-radius: 10px;
            height: 30px;
            width: 30px;
            border: solid 1px #ffffff10;
            margin-bottom: 5px;
        }

        a {
            color: rgb(91, 153, 255);
        }

        .message-content {
            white-space: pre-wrap;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        .message-header {
            font-weight: bold;
            color: #ffffff99;
            margin-bottom: 4px;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="tab-bar">
        <div id="tabs-container"></div>
        <button id="add-tab-btn">+</button>
    </div>
    <div id="input-container">
        <input type="text" id="message-input" placeholder="Type a message...">
    </div>

    <script id="main-script">
        // Kitb was here

        const version = "3E8";

        const gradientStyle = `
            background-image: linear-gradient(67.5deg, #ff8659, #ffcbb8);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-size: 24px;
            font-weight: bold;
            padding: 10px;
        `;

        console.log(`%ccatTyper v.${version}`, gradientStyle);
        console.log("What are you doing here?");
        console.log("To not see IRC messages, run the page with the Query parameter \"&NOIRC\" or enter in the console: irc_disable = true;");
        console.log("To not see chat messages in console, run the page with the Query parameter \"&NOCONSOLECHAT\" or enter in the console: console_chat_disable = true;");
        console.log("To not see console messages time, run the page with the Query parameter \"&NOCONSOLETIME\" or enter in the console: console_timestamp_disable = true;");
        console.log("");

        // SETTINGS
        const params = new URLSearchParams(window.location.search);
        const token = params.get('token');
        const login = params.get('login');
        const timeFormat = params.get('time_format') || 'HH:mm:ss';
        const emotesSize = parseFloat(params.get('emotes_size')) || 1.0;
        const maxHistorySize = parseInt(params.get('history_size')) || 1000;
        let broadcasterId = params.get('broadcaster_id');
        const enabledThirdPartyEmotes = params.get('third_party_emotes')?.split(',') || [];

        let irc_disable = params.get('NOIRC') !== null;
        let console_chat_disable = params.get('NOCONSOLECHAT') !== null;
        let console_timestamp_disable = params.get('NOCONSOLETIME') !== null;

        // TOKENS
        const clientId = 'xrs6iz7t6zk7z5dfrzad4mn1e4bzln'; // Dont forget to delete that! TomFoolery TeaTime

        // HTML ELEMENTS
        const chatEl = document.getElementById('chat');
        const inputEl = document.getElementById('message-input');
        inputEl.style.display = 'none';

        // OTHER
        let socket;
        let reconnectAttempts = 0;
        let channels = {};
        let pingers = [
            { ignoreCase: true, text: login }
        ];
        let activeChannel = null;
        const maxReconnectAttempts = 5;
        const startTime = new Date();
        let lastSent = { message: null, channel: null };

        // For global emotes and badges
        channels["global"] = {
            chat: null,
            messages: null,
            emotes: {},
            badges: {},
            tab: null
        };

        // Category: main
        if (clientId && token) {
            log('Hello world!', 'INIT');
            init();
        }

        function connect() {
            log('Creating connection to twitch.tv...', 'SOCK');
            socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');

            socket.onopen = () => {
                log('Hello, twitch.tv!', 'SOCK');
                sendSocket(`PASS oauth:${token}`);
                sendSocket(`NICK ${login}`);
                sendSocket('CAP REQ :twitch.tv/membership twitch.tv/tags twitch.tv/commands');
                reconnectAttempts = 0;
            };

            socket.onmessage = (event) => {
                const line = event.data.trim();
                if (!irc_disable) {
                    log(line, 'SOCK-RECEIVED');
                }

                if (line.startsWith('PING')) {
                    log('ðŸ“ Ponged!', 'SOCK');
                    sendSocket('PONG');
                    return;
                }

                const parsed = parseIRCMessage(line);

                switch (parsed.command) {
                    case 'PRIVMSG':
                        const username = parsed.tags['display-name'] || parsed.tags.username || 'User';
                        const message = parsed.params[1];
                        addMessage(message, parsed.tags, true, parsed.channel);
                        break;

                    case 'NOTICE':
                        if (parsed.params[1].includes('Login authentication failed')) {
                            alert('Authentication failed');
                        }
                        break;

                    case 'CLEARCHAT':
                        if (parsed.params[1]) {
                            const user = parsed.params[1];
                            const chatContainer = document.getElementById(`chat-${parsed.channel}`);

                            if (chatContainer) {
                                const messages = chatContainer.querySelectorAll(`.message`);
                                messages.forEach(message => {
                                    const usernameElem = message.querySelector('.username');
                                    if (usernameElem && usernameElem.textContent.trim().toLowerCase().replace(': ', '') === user.toLowerCase()) {
                                        message.classList.add('deleted');
                                    }
                                });
                            }

                            if (parsed.tags && parsed.tags['ban-duration']) {
                                const duration = parseInt(parsed.tags['ban-duration'], 10);
                                const durationStr = formatDuration(duration);
                                addSystemMessage(`@${user} was timed out from chat for ${durationStr}`, parsed.channel);
                            } else {
                                addSystemMessage(`@${user} has been banned`, parsed.channel);
                            }
                        } else {
                            addSystemMessage('Chat was cleared', parsed.channel);
                        }
                        break;
                    case 'USERSTATE':
                        if (lastSent.message && lastSent.channel) {
                            addMessage(lastSent.message, parsed.tags, true, lastSent.channel);
                            lastSent = { message: null, channel: null };
                        }
                        break;
                    case 'USERNOTICE':
                        if (parsed.tags['msg-id'] === 'announcement') {
                            const user = parsed.tags['display-name'] || parsed.tags.username || 'Unknown';
                            const announcementMessage = parsed.params[1] || '';
                            const header = 'ðŸ“¢ Announcement';

                            addMessage(
                                announcementMessage,
                                parsed.tags,
                                true,
                                parsed.channel,
                                'announce',
                                header
                            );
                        }
                        break;
                }
            };

            socket.onclose = (event) => {
                log('Connection closed. Monka! ' + event.reason, 'SOCK');
                channels.forEach(function (value, key) {
                    if (value.chat) {
                        addSystemMessage('Disconnected', key);
                    }
                });

                setTimeout(() => {
                    reconnectAttempts++;
                    channels.forEach(function (value, key) {
                        if (value.chat) {
                            addSystemMessage(`Reconnecting...`, key);
                        }
                    });
                    log(`Reconnecting...`, 'SOCK');
                    connect();
                }, 5000);
            };

            socket.onerror = (error) => {
                console.error('WebSocket Error:', error);
                socket.close();
            };
        }

        // Category: UTILS
        // |========= EMOTES =========|
        function replaceEmotes(text, emotes, channel) {
            text = escapeHTML(text);
            const originalText = text;
            text = text.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" rel="nofollow noopener noreferrer">$1</a>');

            // 1. ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° ÑÐ¼Ð¾Ð´Ð·Ð¸ ÐºÐ°Ð½Ð°Ð»Ð°
            let parts = processChannelEmotes(text, channel);

            // 2. ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð³Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½Ñ‹Ñ… ÑÑ‚Ð¾Ñ€Ð¾Ð½Ð½Ð¸Ñ… ÑÐ¼Ð¾Ð´Ð·Ð¸
            parts = processGlobalThirdPartyEmotes(parts, channel);

            parts = parts.filter(item => item !== '' && item !== ' ');

            // 3. ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Twitch-ÑÐ¼Ð¾Ð´Ð·Ð¸
            parts = processTwitchEmotes(parts, emotes, originalText);

            return parts.join(' ');
        }

        function processChannelEmotes(text, channel) {
            const parts = [];
            if (Object.keys(channels[channel].emotes).length === 0) {
                return text.split(' ').flatMap(word => [word, ' ']).slice(0, -1);
            }

            const words = text.split(' ');
            for (let i = 0; i < words.length; i++) {
                const word = words[i];
                if (channels[channel].emotes[word]) {
                    const img = document.createElement('img');
                    img.className = 'emote';
                    img.src = channels[channel].emotes[word].url;
                    img.style.height = `${1.5 * emotesSize}em`;
                    img.loading = 'lazy';
                    img.title = formatEmoteTitle(channels[channel].emotes[word]);
                    parts.push(img.outerHTML);
                } else {
                    parts.push(word);
                }
                if (i < words.length - 1) parts.push(' ');
            }

            return parts;
        }

        function processGlobalThirdPartyEmotes(parts, channel) {
            if (Object.keys(channels["global"].emotes).length === 0) return parts;

            const result = [];
            for (const part of parts) {
                if (part.startsWith('<img')) {
                    result.push(part);
                    continue;
                }

                const words = part.split(' ');
                for (let i = 0; i < words.length; i++) {
                    const word = words[i];
                    if (channels["global"].emotes[word]) {
                        const img = document.createElement('img');
                        img.className = 'emote';
                        img.src = channels["global"].emotes[word].url;
                        img.style.height = `${1.5 * emotesSize}em`;
                        img.loading = 'lazy';
                        img.title = formatEmoteTitle(channels["global"].emotes[word]);
                        result.push(img.outerHTML);
                    } else {
                        result.push(word);
                    }
                    if (i < words.length - 1) result.push(' ');
                }
            }

            return result;
        }

        function processTwitchEmotes(parts, emotes, originalText) {
            if (!emotes || !originalText) return parts;

            const result = [...parts];
            const wordPositions = [];

            let pos = 0;
            originalText.split(" ").forEach((word, index) => {
                const start = pos;
                const end = pos + word.length;
                wordPositions.push({ start, end, index });
                pos = end + 1;
            });

            const emoteList = [];
            emotes.split("/").forEach(part => {
                const [id, positions] = part.split(":");
                positions.split(",").forEach(pos => {
                    const [start, end] = pos.split("-").map(Number);
                    emoteList.push({ id, start, end });
                });
            });

            emoteList.sort((a, b) => a.start - b.start);

            emoteList.forEach(({ id, start, end }) => {
                for (let i = 0; i < wordPositions.length; i++) {
                    const { start: wordStart, end: wordEnd, index: wordIndex } = wordPositions[i];

                    if (start >= wordStart && end <= wordEnd) {
                        const img = document.createElement("img");
                        img.className = "emote";
                        img.loading = 'lazy';
                        img.src = `https://static-cdn.jtvnw.net/emoticons/v2/${id}/default/dark/3.0`;
                        img.style.height = `${1.5 * emotesSize}em`;

                        result[wordIndex] = img.outerHTML;
                        break;
                    }
                }
            });

            return result;
        }

        function formatEmoteTitle(emoteData) {
            return `${emoteData.name}
${emoteData.type} ${emoteData.service} emote
By ${emoteData.author}${emoteData.original_name !== emoteData.name ? `\nOriginal name: ${emoteData.original_name}` : ''}`;
        }

        function escapeHTML(text) {
            return text
                .replaceAll(/[&<>"']/g, (match) => ({
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                }[match]));
        }
        // |==========================|


        // |===== USERNAME COLOR =====|
        const colorMapping = {
            "#0000FF": "#5678fc",    // Blue
            "#8A2BE2": "#b24dff",    // BlueViolet
            "#5F9EA0": "#5ea0c4",    // CadetBlue
            "#D2691E": "#fc8530",    // Chocolate
            "#FF7F50": "#fa895f",    // Coral
            "#1E90FF": "#3b9eff",    // DodgerBlue
            "#B22222": "#ff4a4a",    // FireBrick
            "#DAA520": "#ffce54",    // GoldenRod
            "#00FF00": "#82ff82",    // Green
            "#FF69B4": "#FF69B4",    // HotPink
            "#FF4500": "#ff6e38",    // OrangeRed
            "#FF0000": "#ff4242",    // Red
            "#2E8B57": "#499e6e",    // SeaGreen
            "#00FF7F": "#3dff9e",    // SpringGreen
            "#9ACD32": "#c3f759",    // YellowGreen
        };

        function getCustomColor(hex) {
            return colorMapping[hex] || hex; // Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ ÐºÐ°ÑÑ‚Ð¾Ð¼Ð½Ñ‹Ð¹ Ñ†Ð²ÐµÑ‚ Ð¸Ð»Ð¸ Ð¾Ñ€Ð¸Ð³Ð¸Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹
        }
        // |==========================|


        // |========= SOCKET =========|
        function sendSocket(data) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(data);

                if (!irc_disable) {
                    log(data, 'SOCK SEND');
                }
            }
            else {
                log(`Tried to send message, but socket is not open!`, 'SOCK SEND');
            }
        }

        function sendMessage(message, channel) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                lastSent = { message: message, channel: channel };
                sendSocket(`PRIVMSG #${channel} :${message}`);
                log(`Sended message to #${channel}: ${message}`, 'SM');
            }
            else {
                log(`Tried to send message, but socket is not open!`, 'SM');
            }
        }
        // |==========================|


        // |========= BADGES =========|
        function processBadgeData(data, channel) {
            data.data.forEach(badge => {
                badge.versions.forEach(version => {
                    const key = `${badge.set_id}/${version.id}`;
                    channels[channel].badges[key] = version.image_url_4x;
                });
            });
        }

        async function loadBadges(clientId, token, broadcasterId, channel) {
            try {
                log(`Loading badges for #${channel} (${broadcasterId})...`, 'LB');
                if (broadcasterId) {
                    const channelRes = await fetch(`https://api.twitch.tv/helix/chat/badges?broadcaster_id=${broadcasterId}`, {
                        headers: {
                            'Client-ID': clientId,
                            'Authorization': `Bearer ${token}`
                        }
                    });
                    const channelData = await channelRes.json();
                    processBadgeData(channelData, channel);
                    log(`Loaded! Quantity: ${Object.keys(channels[channel].badges).length}`, 'LB');
                }
            } catch (error) {
                log(`Error loading local badges: ${error.message}`, 'LB');
                console.error(error);
            }
        }

        async function loadGlobalBadges(clientId, token) {
            try {
                log(`Loading global badges...`, 'LGB');
                const globalRes = await fetch('https://api.twitch.tv/helix/chat/badges/global', {
                    headers: {
                        'Client-ID': clientId,
                        'Authorization': `Bearer ${token}`
                    }
                });
                const globalData = await globalRes.json();
                processBadgeData(globalData, "global");
                log(`Loaded! Quantity: ${Object.keys(channels['global'].badges).length}`, 'LGB');
            } catch (error) {
                log(`Error loading global badges: ${error.message}`, 'LB');
                console.error(error);
            }
        }

        function parseBadges(badgesStr) {
            if (!badgesStr) return [];
            return badgesStr.split(',').map(badge => {
                const [setId, version] = badge.split('/');
                return { setId, version };
            });
        }
        // |==========================|


        // |========== CHAT ==========|
        function addSystemMessage(text, channel) {
            const msgDiv = document.createElement('div');
            msgDiv.className = 'message';

            const timeSpan = document.createElement('span');
            timeSpan.className = 'timestamp';
            timeSpan.textContent = formatTime(Date.now());
            msgDiv.appendChild(timeSpan);

            const systemSpan = document.createElement('span');
            systemSpan.style.color = '#888';
            systemSpan.textContent = text;
            msgDiv.appendChild(systemSpan);

            if (!console_chat_disable) {
                log(`@S #${channel} system: ${text}`, 'CHAT');
            }

            const chatEl = channels[channel].chat;
            if (!chatEl) {
                chatEl = document.getElementById(`chat-${channel}`);
            }

            const atBottom = chatEl.scrollTop + chatEl.clientHeight >= chatEl.scrollHeight - 5;

            chatEl.appendChild(msgDiv);

            if (atBottom) {
                chatEl.scrollTop = chatEl.scrollHeight;
            }

            if (chatEl.children.length > maxHistorySize) {
                chatEl.removeChild(chatEl.firstElementChild);
            }
        }

        inputEl.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && inputEl.value.trim()) {
                sendMessage(inputEl.value, activeChannel);
                inputEl.value = '';
            }
        }); // Read send

        function addMessage(message, tags, isAppend, channel, extraClasses = '', headerText = '') {
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${extraClasses}`.trim();
            const originalMessage = message;

            if (headerText) {
                const headerSpan = document.createElement('div');
                headerSpan.className = 'message-header';
                headerSpan.textContent = headerText;
                msgDiv.appendChild(headerSpan);
            }

            let msgInfo = '';

            // Store message ID for replies
            if (tags['id']) {
                msgDiv.id = `msg-${tags['id']}`;
            }

            let isAction = false;
            if (message.startsWith('\x01ACTION') && message.endsWith('\x01')) {
                isAction = true;
                message = message.slice(8, -1);
                msgInfo += 'M';
            }

            // Reply handling
            const parentId = tags['reply-parent-msg-id'];
            if (parentId) {
                msgInfo += 'R';
                const parentMsg = document.getElementById(`msg-${parentId}`);
                if (parentMsg) {
                    const replyRef = document.createElement('div');
                    replyRef.className = 'reply-reference';

                    let msg = parentMsg.querySelector('.message-content').textContent;

                    replyRef.innerHTML = `â†’ In reply to ${parentMsg.querySelector('.username').textContent}${msg.slice(0, 75) + (msg === msg.slice(0, 72) ? "" : "...")}`;
                    replyRef.style.cssText = "margin-left: 10px; padding-left: 10px; border-left: 1px solid #555; cursor: pointer; font-style: italic;";

                    replyRef.addEventListener('click', () => {
                        parentMsg.scrollIntoView({ behavior: 'smooth', block: 'center' });

                        parentMsg.classList.add('highlight');
                        setTimeout(() => {
                            parentMsg.classList.remove('highlight');
                        }, 1000);
                    });

                    msgDiv.appendChild(replyRef);
                    message = message.slice(parentMsg.querySelector('.username').textContent.replaceAll(': ', '').length + 2);
                }
            }

            // time
            const timeSpan = document.createElement('span');
            timeSpan.className = 'timestamp';
            timeSpan.textContent = formatTime(tags['tmi-sent-ts'] ? parseInt(tags['tmi-sent-ts']) : Date.now());
            msgDiv.appendChild(timeSpan);

            // badges
            const badgesContainer = document.createElement('span');
            badgesContainer.className = 'badges';
            if (tags.badges) {
                const badges = parseBadges(tags.badges);
                badges.forEach(badge => {
                    const badgeUrl = channels[channel].badges[`${badge.setId}/${badge.version}`];
                    const badgeGlobalUrl = channels['global'].badges[`${badge.setId}/${badge.version}`];
                    if (badgeUrl || badgeGlobalUrl) {
                        const img = document.createElement('img');
                        if (badgeUrl) {
                            img.src = badgeUrl;
                        } else {
                            img.src = badgeGlobalUrl;
                        }
                        img.className = 'badge';
                        img.title = badge.setId;
                        badgesContainer.appendChild(img);
                    }
                });
            }
            msgDiv.appendChild(badgesContainer);

            // username
            const userSpan = document.createElement('span');
            userSpan.className = 'username';
            const originalColor = tags['color'] || '#b3b3b3';
            const customColor = getCustomColor(originalColor);
            userSpan.style.color = customColor;
            userSpan.textContent = (tags['display-name'] || tags.username || 'undefined') + (isAction ? ' ' : ': ');
            msgDiv.appendChild(userSpan);

            // message
            const messageSpan = document.createElement('span');
            messageSpan.className = 'message-content';
            messageSpan.innerHTML = replaceEmotes(message, tags['emotes'], channel);
            if (isAction) {
                messageSpan.style.color = customColor;
            }
            msgDiv.appendChild(messageSpan);

            for (const { ignoreCase, text } of pingers) {
                const message = ignoreCase ? originalMessage.toLowerCase() : originalMessage;
                const target = ignoreCase ? text.toLowerCase() : text;

                if (message.includes(target)) {
                    msgDiv.classList.add('ping');
                    break;
                }
            }

            const tabEl = channels[channel].tab;

            if (!tabEl) {
                tabEl = document.getElementById(`tab-${channel}`);
            }

            if (!tabEl.classList.contains('active')) {
                for (const { ignoreCase, text } of pingers) {
                    const message = ignoreCase ? originalMessage.toLowerCase() : originalMessage;
                    const target = ignoreCase ? text.toLowerCase() : text;

                    if (message.includes(target)) {
                        tabEl.classList.add('ping');
                        break;
                    }
                }

                if (!tabEl.classList.contains('ping')) {
                    tabEl.classList.add('messages');
                }
            }

            const chatEl = channels[channel].chat;

            if (!chatEl) {
                chatEl = document.getElementById(`chat-${channel}`);
            }

            const atBottom = chatEl.scrollTop + chatEl.clientHeight >= chatEl.scrollHeight - 5;

            if (isAppend) {
                chatEl.appendChild(msgDiv);
            } else {
                chatEl.prepend(msgDiv);
            }

            if (atBottom) {
                chatEl.scrollTop = chatEl.scrollHeight;
            }

            // Message limit
            if (chatEl.children.length > maxHistorySize) {
                chatEl.removeChild(chatEl.firstElementChild);
            }

            if (!console_chat_disable) {
                log(`@${msgInfo} #${channel} ${tags['display-name'] || tags.username || 'undefined'}: ${message}`, 'CHAT');
            }
        }

        function formatTime(timestamp) {
            const date = new Date(timestamp);
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            const miliseconds = String(date.getMilliseconds()).padStart(2, '0');

            return timeFormat
                .replace('HH', hours)
                .replace('mm', minutes)
                .replace('ss', seconds)
                .replace('SSS', miliseconds);
        }

        function parseIRCMessage(line) {
            const tags = {};
            let prefix = '';
            let command = '';
            let params = [];
            let channel = undefined;

            // tags
            if (line.startsWith('@')) {
                const tagEnd = line.indexOf(' ');
                const tagString = line.slice(1, tagEnd);
                line = line.slice(tagEnd + 1);

                tagString.split(';').forEach(tag => {
                    const [key, value] = tag.split('=');
                    tags[key] = value || '';
                });
            }

            // prefix
            if (line.startsWith(':')) {
                const prefixEnd = line.indexOf(' ');
                prefix = line.slice(1, prefixEnd);
                line = line.slice(prefixEnd + 1);
            }

            // command
            const commandEnd = line.indexOf(' ');
            command = line.slice(0, commandEnd);
            line = line.slice(commandEnd + 1);

            // parameters
            while (line.length > 0) {
                if (line.startsWith(':')) {
                    params.push(line.slice(1));
                    line = '';
                } else {
                    const spaceIndex = line.indexOf(' ');
                    if (spaceIndex === -1) {
                        params.push(line);
                        line = '';
                    } else {
                        params.push(line.slice(0, spaceIndex));
                        line = line.slice(spaceIndex + 1);
                    }
                }
            }
            
            if ((command === 'PRIVMSG' || command === 'CLEARCHAT' || command === 'USERNOTICE') && params.length > 0) {
                channel = params[0].replace('#', '');
            }

            return {
                tags,
                prefix,
                command,
                params,
                channel
            };
        }

        async function loadHistoricalMessages(channel) {
            if (!channel) return;

            try {
                log(`Getting for #${channel}...`, 'HISTORY');
                const res = await fetch(`https://recent-messages.robotty.de/api/v2/recent-messages/${channel}`, {
                    headers: { 'Accept': 'application/json' }
                });

                if (!res.ok) throw new Error('HTTP error ' + res.status);

                const data = await res.json();
                if (data.error) throw new Error(data.error);

                // Process messages in reverse to maintain order
                for (const line of data.messages) {
                    const parsed = parseIRCMessage(line.trim());
                    if (parsed.command === 'PRIVMSG') {
                        addMessage(parsed.params[1], parsed.tags, true, channel);
                    } else if (parsed.command === 'CLEARCHAT') {
                        if (parsed.params[1]) {
                            const user = parsed.params[1];
                            const chatContainer = document.getElementById(`chat-${parsed.channel}`);

                            if (chatContainer) {
                                const messages = chatContainer.querySelectorAll(`.message`);
                                messages.forEach(message => {
                                    const usernameElem = message.querySelector('.username');
                                    if (usernameElem && usernameElem.textContent.trim().toLowerCase().replaceAll(':', '').replaceAll(' ', '') === user.toLowerCase()) {
                                        message.classList.add('deleted');
                                    }
                                });
                            }

                            if (parsed.tags && parsed.tags['ban-duration']) {
                                const duration = parseInt(parsed.tags['ban-duration'], 10);
                                const durationStr = formatDuration(duration);
                                addSystemMessage(`@${user} was timed out from chat for ${durationStr}`, parsed.channel);
                            } else {
                                addSystemMessage(`@${user} has been banned`, parsed.channel);
                            }
                        } else {
                            addSystemMessage('Chat was cleared', parsed.channel);
                        }
                    } else if (parsed.command === 'USERNOTICE') {
                        if (parsed.tags['msg-id'] === 'announcement') {
                            const user = parsed.tags['display-name'] || parsed.tags.username || 'Unknown';
                            const announcementMessage = parsed.params[1] || '';
                            const header = 'ðŸ“¢ Announcement';

                            addMessage(
                                announcementMessage,
                                parsed.tags,
                                true,
                                parsed.channel,
                                'announce',
                                header
                            );
                        }
                    }
                }
                log(`Loaded for #${channel}!`, 'HISTORY');
            } catch (error) {
                addSystemMessage('History load failed: ' + error.message, channel);
                log(`Error loading for #${channel}!`, 'HISTORY');
                console.error(error);
            }
        }

        function formatDuration(seconds) {
            if (seconds < 60) {
                return `${seconds} second${seconds === 1 ? '' : 's'}`;
            } else if (seconds < 3600) {
                const minutes = Math.floor(seconds / 60);
                return `${minutes} minute${minutes === 1 ? '' : 's'}`;
            } else if (seconds < 86400) {
                const hours = Math.floor(seconds / 3600);
                return `${hours} hour${hours === 1 ? '' : 's'}`;
            } else {
                const days = Math.floor(seconds / 86400);
                return `${days} day${days === 1 ? '' : 's'}`;
            }
        }
        // |==========================|


        // |======= TWITCH API =======|
        async function getBroadcasterId(channelName, clientId, token) {
            log(`Getting #${channelName} id...`, 'GBI');
            const res = await fetch(`https://api.twitch.tv/helix/users?login=${channelName}`, {
                headers: {
                    'Client-ID': clientId,
                    'Authorization': `Bearer ${token}`
                }
            });
            const data = await res.json();
            log(`#${channelName} â†’ ${data.data[0]?.id}`, 'GBI');
            return data.data[0]?.id;
        }
        // |==========================|


        // |=== THIRD PARTY EMOTES ===|
        // #GLOBAL EMOTES
        async function loadGlobalThirdPartyEmotes() {
            log(`Loading global third party emotes... (${enabledThirdPartyEmotes.join(', ')})`, 'LGTPE');
            const promises = [];

            if (enabledThirdPartyEmotes.includes('7TV')) {
                promises.push(loadGlobal7TVEmotes());
            }
            if (enabledThirdPartyEmotes.includes('BTTV')) {
                promises.push(loadGlobalBTTVEmotes());
            }
            if (enabledThirdPartyEmotes.includes('FFZ')) {
                promises.push(loadGlobalFFZEmotes());
            }

            await Promise.allSettled(promises);
            log(`Loaded!`, 'LGTPE');
        }

        async function loadGlobal7TVEmotes() {
            try {
                const globalRes = await fetch('https://7tv.io/v3/emote-sets/global');
                const globalData = await globalRes.json();
                process7TVEmotes(globalData.emotes, 'Global', 0, 'global');
            } catch (error) {
                console.error('7TV global emotes load error:', error);
                //addSystemMessage("7TV global emotes load error");
            }
        }

        async function loadGlobalBTTVEmotes() {
            try {
                const globalRes = await fetch('https://api.betterttv.net/3/cached/emotes/global');
                const globalData = await globalRes.json();
                processBTTVEmotes(globalData, 'Global', 0, 'global');
            } catch (error) {
                console.error('BTTV global emotes load error:', error);
                //addSystemMessage("BTTV global emotes load error");
            }
        }

        async function loadGlobalFFZEmotes() {
            try {
                const globalRes = await fetch('https://api.frankerfacez.com/v1/set/3');
                const globalData = await globalRes.json();
                processFFZEmotes(globalData.set.emoticons, 'Global', 0, 'global');
            } catch (error) {
                console.error('FFZ global emotes load error:', error);
                //addSystemMessage("FFZ global emotes load error");
            }
        }

        // #LOCAL EMOTES
        async function loadThirdPartyEmotes(id, channel) {
            log(`Loading third party emotes for #${channel} (${id})... (${enabledThirdPartyEmotes.join(', ')})`, 'LTPE');
            const promises = [];

            if (enabledThirdPartyEmotes.includes('7TV')) {
                promises.push(load7TVEmotes(id, channel));
            }
            if (enabledThirdPartyEmotes.includes('BTTV')) {
                promises.push(loadBTTVEmotes(id, channel));
            }
            if (enabledThirdPartyEmotes.includes('FFZ')) {
                promises.push(loadFFZEmotes(id, channel));
            }

            await Promise.allSettled(promises);
            log(`Loaded!`, 'LTPE');
        }

        async function load7TVEmotes(id, channel) {
            try {
                const channelRes = await fetch(`https://7tv.io/v3/users/twitch/${id}`);
                const channelData = await channelRes.json();
                process7TVEmotes(channelData.emote_set.emotes, 'Channel', 1, channel);
            } catch (error) {
                log(`7TV error: ` + error.message, 'load7TVEmotes');
                console.error(error);
                addSystemMessage("7TV channel emotes load error", channel);
            }
        }

        async function loadBTTVEmotes(id, channel) {
            try {
                const channelRes = await fetch(`https://api.betterttv.net/3/cached/users/twitch/${id}`);
                const channelData = await channelRes.json();
                processBTTVEmotes(channelData.sharedEmotes, 'Shared channel', 1, channel);
                processBTTVEmotes(channelData.channelEmotes, 'Channel', 2, channel);
            } catch (error) {
                log(`BTTV error: ` + error.message, 'loadBTTVEmotes');
                console.error(error);
                addSystemMessage("BTTV load error", channel);
            }
        }

        async function loadFFZEmotes(id, channel) {
            try {
                const channelRes = await fetch(`https://api.frankerfacez.com/v1/room/id/${id}`);
                const channelData = await channelRes.json();
                const setId = channelData.room.set;
                const setRes = await fetch(`https://api.frankerfacez.com/v1/set/${setId}`);
                const setData = await setRes.json();
                processFFZEmotes(setData.set.emoticons, 'Channel', 1, channel);
            } catch (error) {
                log(`FFZ error: ` + error.message, 'loadFFZEmotes');
                console.error(error);
                addSystemMessage("FFZ load error", channel);
            }
        }

        // #PROCCESS EMOTES
        function processBTTVEmotes(emotes, prefix, type_id, channel) {
            emotes.forEach(e => {
                try {
                    channels[channel].emotes[e.code] = {
                        url: `https://cdn.betterttv.net/emote/${e.id}/3x`,
                        service: 'bttv',
                        type: prefix,
                        type_id: type_id,
                        is_zero_lenght: false,
                        author: (prefix != 'Global' ? (prefix != 'Channel' ? (e.hasOwnProperty('user') && e.user.hasOwnProperty('name') ? e.user.name : '<suspended user>') : channel) : 'BTTV'),
                        author_url: (e.hasOwnProperty('user') && e.user.hasOwnProperty('id')) || e.hasOwnProperty('userId') ? `https://betterttv.com/users/${(prefix != 'Global' & prefix != 'Channel' ? e.user.id : e.userId)}` : '',
                        emote_url: `https://betterttv.com/emotes/${e.id}`,
                        id: e.id,
                        original_name: e.code,
                        name: e.code
                    };
                } catch (error) {
                    log(`BTTV emote process error`, 'PBTTVE');
                    console.error(error);
                }
            });
        }

        function processFFZEmotes(emotes, prefix, type_id, channel) {
            emotes.forEach(e => {
                try {
                    const size = Math.min(4, Math.floor(emotesSize * 2)); // 1x, 2x Ð¸Ð»Ð¸ 4x
                    channels[channel].emotes[e.name] = {
                        url: e.urls[size] || e.urls['2'],
                        service: 'ffz',
                        type: prefix,
                        type_id: type_id,
                        is_zero_lenght: false,
                        author: e.hasOwnProperty('owner') && e.owner.hasOwnProperty('display_name') ? e.owner.display_name : '<suspended user>',
                        author_url: e.hasOwnProperty('owner') && e.owner.hasOwnProperty('display_name') ? `https://www.frankerfacez.com/${e.owner.display_name}/submissions` : '',
                        emote_url: `https://www.frankerfacez.com/emoticon/${e.id}-${e.name}`,
                        id: e.id,
                        original_name: e.name,
                        name: e.name
                    };
                } catch (error) {
                    log(`FFZ emote process error`, 'PFFZE');
                    console.error(error);
                }
            });
        }

        function process7TVEmotes(emotes, prefix, type_id, channel) {
            emotes.forEach(e => {
                try {
                    const bestQuality = e.data.host.files.reduce((best, current) =>
                        current.width > best.width ? current : best
                    );
                    channels[channel].emotes[e.name] = {
                        url: `https:${e.data.host.url}/${bestQuality.name}`,
                        service: '7tv',
                        type: prefix,
                        type_id: type_id,
                        is_zero_lenght: e.data.flags == 256,
                        author: e.data.hasOwnProperty('owner') && e.data.owner.hasOwnProperty('display_name') ? e.data.owner.display_name : '<suspended user>',
                        author_url: e.data.hasOwnProperty('owner') && e.data.owner.hasOwnProperty('id') ? `https://7tv.app/users/${e.data.owner.id}` : '',
                        emote_url: `https://7tv.app/emotes/${e.id}`,
                        id: e.id,
                        original_name: e.data.name,
                        name: e.name
                    };
                } catch (error) {
                    log(`7TV emote process error`, 'P7TVE');
                    console.error(error);
                }
            });
        }
        // |==========================|


        // |========== TABS ==========|
        function initTab(channelName) {
            log(`Inititalization for #${channelName}...`, 'TABINIT');
            const tabsContainer = document.getElementById('tabs-container');
            const tab = document.createElement('div');
            tab.className = 'tab';
            tab.id = `tab-${channelName}`;
            tab.textContent = channelName;
            tab.addEventListener('click', () => switchChannel(channelName));
            tabsContainer.appendChild(tab);

            const chat = document.createElement('div');
            chat.id = `chat-${channelName}`;
            chat.className = 'chat-container';
            chat.style.display = 'none';
            document.body.insertBefore(chat, document.getElementById('input-container'));

            channels[channelName] = {
                chat: chat,
                messages: [],
                emotes: {},
                badges: {},
                tab: tab
            };
            log(`Inititalized!`, 'TABINIT');
        }

        function switchChannel(channelName) {
            let oldChannel = activeChannel;
            
            if (activeChannel) {
                channels[activeChannel].chat.style.display = 'none';
            }
            activeChannel = channelName;
            channels[activeChannel].chat.style.display = 'block';
            channels[activeChannel].chat.scrollTop = channels[activeChannel].chat.scrollHeight;
            inputEl.style.display = 'block';

            if (oldChannel) {
                let oldChannelTabEl = document.getElementById(`tab-${oldChannel}`);
                oldChannelTabEl.classList.remove('active');
            }
            let newChannelTabEl = document.getElementById(`tab-${channelName}`);
            newChannelTabEl.className = 'tab active';

            log(`#${oldChannel} â†’ #${activeChannel}`, 'SC');
        }

        document.getElementById('add-tab-btn').addEventListener('click', () => {
            let newChannel = prompt('Enter channel name:');
            if (newChannel) {
                newChannel = newChannel.toLowerCase();

                if (!channels[newChannel]) {
                    log(`Adding new channel - #${newChannel}`, 'ATBC');
                    initTab(newChannel);
                    switchChannel(newChannel);
                    loadChannelData(newChannel);
                    log(`#${newChannel} added!`, 'ATBC');
                }
            }
        });

        async function loadChannelData(channelName) {
            log(`Loading channel data for #${channelName}...`, 'LCD');
            const channelData = channels[channelName];

            const id = await getBroadcasterId(channelName, clientId, token);
            if (id) {
                channelData.broadcasterId = id;

                await Promise.allSettled([
                    loadBadges(clientId, token, id, channelName),
                    loadThirdPartyEmotes(channelData.broadcasterId, channelName)
                ]);

                addSystemMessage('Third-party emotes loaded', channelName);
                await loadHistoricalMessages(channelName);

                sendSocket(`JOIN #${channelName}`);
                log(`Data for #${channelName} was loaded!`, 'LCD');
            }
            else {
                addSystemMessage('This channel was not found!', channelName);
                log(`#${channelName} was not found!`, 'LCD');
            }
        }
        // |==========================|

        // START
        async function init() {
            log(`Waking up...`, 'INIT');
            // Existing badge loading logic...
            await Promise.allSettled([
                loadGlobalBadges(clientId, token),
                loadGlobalThirdPartyEmotes()
            ]);

            log(`Good morning!`, 'INIT');
            log(`Emotes loaded: ${Object.keys(channels["global"].emotes).length}`, 'INIT');
            connect();
        }

        // LOG
        function log(text, section) {
            const sectionStyle = `
                background-image: linear-gradient(67.5deg, #ff8659, #ffcbb8);
                color: transparent;
                background-clip: text;
            `;
            if (console_timestamp_disable) {
                console.log(`[%c${section}%c] ${text}`, sectionStyle, '');
            } else {
                console.log(`[%c${new Date() - startTime}%c] [%c${section}%c] ${text}`, sectionStyle, '', sectionStyle, '');
            }
        }
    </script>
</body>
</html>
